<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS ntCPP</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
  </script>
</head>
<body>

<div class="head">
<h1>EPICS ntCPP</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 16-Oct-2015</h2>

  <dl>
    <dt>Latest version:</dt>
    <dd><a
      href="ntCPP.html">ntCPP.html</a>
    </dd>
    <dt>This version:</dt>
    <dd><a
      href="ntCPP_20151016.html">ntCPP_20151016.html</a>
    </dd>
    <dt>Previous version:</dt>
    <dd><a
      href="ntCPP_20141009.html">ntCPP_20141009.html</a>
    </dd>
    <dt>Editors:</dt>
   <dd> Marty Kraimer, BNL<br />
      Matej Sekoranja, CosyLab<br />
      David Hickin, Diamond Light Source
      </dd>
  </dl>

  <p class="copyright">This product is made available subject to acceptance of the <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">EPICS open source
license.</a></p>
<hr />
</div>
<h2 class="nocount">Abstract</h2>

<p>EPICS Version 4 provides efficient
storage, access, and communication, of memory resident structured data.
The EPICS V4 Normative Types are a collection of structured data types
that can be used by the application level of EPICS V4 network endpoints,
to interoperably exchange scientific data.
normativeTypesCPP is the C++ implementation.
It is one part of the set of related products in the EPICS
V4 control system programming environment:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumentsV4.html">relatedDocumentsV4.html</a>
</p>


<h2 class="nocount">Status of this Document</h2>

<p>This is the 16-Oct-2015 version of the C++ implementation of pvData.
</p>


<p>RELEASE_NOTES.md provides changes since the last release.
TODO.md describes things to do before the next release.
</p>



<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>
<div id="contents" class="contents">


<h2>Introduction</h2>

<p>This manual assumes that the reader is familiar with the material in
<a
href="http://epics-pvdata.sourceforge.net/docbuild/pvDataCPP/tip/documentation/pvDataCPP.html"
>
pvDataCPP.html
</a>
</p>
<p>At present the following normative types are implemented:</p>
<ul>
  <li><b>NTScalar</b></li>
  <li><b>NTScalarArray</b></li>
  <li><b>NTEnum</b></li>
  <li><b>NTMatrix</b></li>
  <li><b>NTURI</b></li>
  <li><b>NTNameValue</b></li>
  <li><b>NTTable</b></li>
  <li><b>NTAttribute</b></li>
  <li><b>NTMultiChannel</b></li>
  <li><b>NTNDArray</b></li>
  <li><b>NTContinuum</b></li>
  <li><b>NTHistogram</b></li>
  <li><b>NTAggregate</b></li>
</ul>

<p>There is also additional support for NTAttributes which are extended as required by NTNDArray.</p>

<p>Thus normativeTypesCPP implements fully the <a href="http://epics-pvdata.sourceforge.net/alpha/normativeTypes/normativeTypes_20150316.html">
March 16 2015</a> version the Normative Types Specification.</p>

<p>This version of the document only covers the types originally implemented:</p>

<dl>
  <dt>NTScalar</dt>
     <dd>This has a value field that has type scalar.</dd>
  <dt>NTScalarArray</dt>
     <dd>This has a value field that has type scalarArray.</dd>
  <dt>NTNameValue</dt>
      <dd>This has a field name that is a string array
       and a field value that has type scalarArray.
       Each name[i] is associated with value[i].
      </dd>
  <dt>NTTable</dt>
      <dd>This has a number of scalar array fields representing the columns of
a table as well as a string array called containing representing column headers.
     </dd>
  <dt>NTMultiChannel</dt>
     <dd>This has a value field that is a union array.
      A primary use of this type is to access data from a set of pvAccess channels.
      Each element of value holds data from a channel.</dd>
  <dt>NTNDArray</dt>
     <dd>This type holds NDArray data as defined by the areaDetector facility.
     </dd>
</dl>

<p>Documentation for the remaining types will addressed in the next version of this document.</p>

<p>Each normative type consists of a set of mandatory fields, a set of optional fields,
and any arbitrary number of extra fields.
The mandatory and optional fields are meant for use by standard tools such
as Display Managers and Alarm Handlers.
The extra fields are for specialized tools.
</p>
<p>
A helper class NTField is provided to enforce the proper implementation  of property fields
as defined by pvData.
A property field is normally associated with a field that has the name "value".
The property fields currently used are alarm, timeStamp, display, control, and alarmLimit.
In addition pvData defines a standard structure for a value field that represents
enumerated values.
NTField has methods associated with each of these.
</p>
<p>An include file "nt.h" includes all the other header files that are provided by ntCPP.
</p>
<p>The next section describes NTField.
Next a set of standard optional fields used by many normative types is described.
Then each normative type is described.
</p>


<h2>NTField</h2>

<p>These are helper classes for creating standard fields for normative types.
There is a single instance of this class, which is obtained via NTField::get().
</p>
<pre>class NTField{
public:
    static NTFieldPtr get();
    ~NTField() {}

    bool isEnumerated(FieldConstPtr const &amp; field);
    bool isTimeStamp(FieldConstPtr const &amp; field);
    bool isAlarm(FieldConstPtr const &amp; field);
    bool isDisplay(FieldConstPtr const &amp; field);
    bool isAlarmLimit(FieldConstPtr const &amp; field);
    bool isControl(FieldConstPtr const &amp; field);

    StructureConstPtr createEnumerated();
    StructureConstPtr createTimeStamp();
    StructureConstPtr createAlarm();
    StructureConstPtr createDisplay();
    StructureConstPtr createControl();

    StructureArrayConstPtr createEnumeratedArray();
    StructureArrayConstPtr createTimeStampArray();
    StructureArrayConstPtr createAlarmArray();
};</pre>

<p>where</p>
<dl>
  <dt>isEnumerated</dt>
    <dd>Is the field an enumerated structure?</dd>
  <dt>isTimeStamp</dt>
    <dd>Is the field an timeStamp structure?</dd>
  <dt>isAlarm</dt>
    <dd>Is the field an alarm structure?</dd>
  <dt>isDisplay</dt>
    <dd>Is the field an display structure?</dd>
  <dt>isAlarmLimit</dt>
    <dd>Is the field an alarmLimit structure?</dd>
  <dt>isControl</dt>
    <dd>Is the field an control structure?</dd>
  <dt>createEnumerated</dt>
    <dd>Create an introspection interface for an enumerated structure.</dd>
  <dt>createTimeStamp</dt>
    <dd>Create an introspection interface for a timeStamp structure.</dd>
  <dt>createAlarm</dt>
    <dd>Create an introspection interface for an alarm structure.</dd>
  <dt>createDisplay</dt>
    <dd>Create an introspection interface for a display structure.</dd>
  <dt>createControl</dt>
    <dd>Create an introspection interface for a control structure.</dd>
  <dt>createEnumeratedArray</dt>
    <dd>Create an introspection interface for an structureArray of enumerated
      structures.</dd>
  <dt>createTimeStampArray</dt>
    <dd>Create an introspection interface for an structureArray of timeStamp
      structures.</dd>
  <dt>createAlarmArray</dt>
    <dd>Create an introspection interface for an structureArray of alarm
      structures.</dd>
</dl>
<h2>Property Field Definitions</h2>
<h3>Definition: value</h3>
<p>Often a property field is associated with another field.
This other field is referred to as the value field.
Usually the value field will have the field name "value".
An example is:</p>
<pre>
structure parent
    double    value
    structure alarm
</pre>
<p>In this example the alarm field reports alarms for the value field.</p>

<h3>alarm</h3>
<p>An alarm structure is used to report alarms and other problems to the client.
An alarm may be associated with a value field or can be used by a server
to report problems to the client.
An alarm attached to a substructure of the top-level structure is normally
associated with a value field.
An alarm field attached to the top-level structure can be used for either:
</p>
<ol>
   <li>If the top-level structure has a value field then it is an alarm
     for that field.
    </li>
   <li>To report other problems to the client.</li>
</ol>
<p>If alarms do appear at multiple levels then an alarm is always
provided at the top-level.
It uses "maximize severity" to report the highest level severity
of all alarms, i.e. the top-level severity is the maximum severity
of all the alarms.</p>
<p>An example is:</p>
<pre>
structure top
   structure alarm
   structure power
       double value
       structure alarm
   structure voltage
       double value
       structure alarm
   structure current
       double value
       structure alarm
</pre>
<p>In this example power, voltage, and current all have an associated alarm.
The top-level alarm would have a severity that matches the highest level
severity of power, voltage, an current.</p>

<p>A alarm structure has the following fields:</p>
<pre>
structure alarm
    int severity
    int status
    string message
</pre>
<p>Clients and Servers should use <b>alarm.h</b> and <b>pvAlarm.h</b> which are
provided by pvDataCPP instead of directly using the alarm structure itself.
In particular severity and status are defined as:</p>
<pre>
enum AlarmSeverity {
 noAlarm,minorAlarm,majorAlarm,invalidAlarm,undefinedAlarm
};

enum AlarmStatus {
    noStatus,deviceStatus,driverStatus,recordStatus,
    dbStatus,confStatus,undefinedStatus,clientStatus
};
</pre>
<h3>timeStamp</h3>
<p>A timeStamp provides the time when the server executes or the time when
a the data for a value field was collected.
There can be multiple timeStamp fields.
A timeStamp associated with a substructure is usually associated with
a value field.
An timeStamp field attached to the top-level structure can be used for either:
</p>
<ol>
   <li>If the top-level structure has a value field then it can be the
     timeStamp for that field.
   </li>
   <li>The time when the server executed.</li>
</ol>
<p>NTNDArray is an example that has two top-level timeStamp fields with different
field names because it wants to report both.</p>

<p>A timeStamp structure has the following fields:</p>
<pre>
structure timeStamp
    long secondsPastEpoch
    int nanoseconds
    int userTag
</pre>
<p>Clients and Servers should use <b>timeStamp.h</b> and <b>pvTimeStamp.h</b>
which are provided by pvDataCPP instead of directly using the timeStamp structure itself.
Note that <b>timeStamp.h</b> provides many methods for manipulating time.
</p>
<p>The meaning of the fields is:</p>
<dl>
   <dt>secondsPastEpoch</dt>
      <dd>seconds since the posix epoch, i.e. Jan 1, 1970 00:00:00 UTC.</dd>
   <dt>nanoseconds</dt>
       <dd>nanoseconds since the secondsPastEpoch.</dd>
   <dt>userTag</dt>
        <dd>service specific.</dd>
</dl>

<h3>control</h3>
<p>This is used to specify operational limits for a numeric scalar value field.</p>
<pre>
structure control
    double limitLow
    double limitHigh
    double minStep
</pre>
<p>Servers should use <b>control.h</b> and <b>pvControl.h</b> which are
provided by pvDataCPP instead of directly using the control structure itself.
Note that <b>control.h</b> provides many methods for manipulating time.
</p>
<h3>display</h3>
<p>This is used to specify display limits and other information for a numeric scalar value field.</p>
<pre>
structure display
    double limitLow
    double limitHigh
    string description
    string format
    string units
</pre>
<p>Note that the format should be a simplified version of the standard
C formatting conventions.</p>
<h3>enumerated</h3>
<p>This is used to specify a set of choices and an index that selects one
of the choices.
For readers familiar with EPICS core this is like the ENUM types.</p>
<pre>
structure
    int index
    string[] choices
</pre>
<h3>alarmLimit</h3>
<p>This is used to specify alarm limits for a double scalar value field.
It can be used by plotting tools to show alarm limits and associated severities.
</p>
<pre>
structure 
    boolean active
    double lowAlarmLimit
    double lowWarningLimit
    double highWarningLimit
    double highAlarmLimit
    int lowAlarmSeverity
    int lowWarningSeverity
    int highWarningSeverity
    int highAlarmSeverity
    double hysteresis
</pre>
<p><b>NOTE:</b> NTField, described above, has support for checking to see if
a structure is an alarmLimit structure but no other support for alarmLimit.</p>
<p>
pvData has support named <b>valueAlarm</b> instead of <b>alarmLimit</b>
(alarmLimit is identical to valueAlarm for type double).
For numeric types the field names are the same but the type
for lowAlarmLimit, lowWarningLimit, highWarningLimit, and highAlarmLimit
is based on the scalarType.
pvData also defines valueAlarm for a scalar boolean value field
and for an enumerated structure.
For these completely different field names are defined.
valueAlarm is more for use by servers than for clients.
Thus normative types only defines alarmLimit since this is what
clients like plot tools use.
If the valueAlarm fields, including alarmLimit, are desired than the standardField support from
pvData can be used to generate a valueAlarm field as an extra field.
</p>

<h2>Normative Type Common Features</h2>
<p>Each normative type has two classes: a builder and a class for the normative type itself.</p>
<h3>Normative Type Builder</h3>
<p>This is a class that can create one of the following:</p>
<dl>
   <dt>Structure</dt>
     <dd>The introspection instance for the data structure associated with the type.</dd>
   <dt>PVStructure</dt>
     <dd>The data instance for the data structure associated with the type.</dd>
    <dt>NTType</dt>
      <dd>The instance for the NT type.
        For example <b>NTScalar</b>
      </dd>
</dl>
<p>Each builder also has a number of additional methods for optional fields
and a method to add extra fields.</p>
<h3>Normative Type Class</h3>
<p>
This has methods to do the following:</p>
<dl>
   <dt>Create instance</dt>
     <dd>A instance of a object can be created via a builder or from an existing PVStructure</dd>
   <dt>Attach a Property</dt>
      <dd>For the following optional fields an object to manipulate the fields can be attached:
         alarm, timeStamp, display, and control.</dd>
   <dt>Get Data Interfaces</dt>
      <dd>Each type has a method getPVStructure to get the entire data structure.
       In addition there is a method to get the data interface for each mandatory
       and optional field.</dd>
</dl>
<h2>Normative Type NTScalar</h2>
<p>This has the following fields:</p>
<pre>
epics:nt/NTScalar:1.0
    double value                        // mandatory and can be any numeric type
    string descriptor                   // optional
    alarm_t alarm                       // optional
        int severity
        int status 
        string message
    time_t timeStamp                    // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    display_t display                   // optional
        double limitLow
        double limitHigh
        string description
        string format
        string units
    control_t control                   // optional
        double limitLow
        double limitHigh
        double minStep
    string extra1                       // extra
    string[] extra2                     //
</pre>
<h3>NTScalarBuilder</h3>
<p>This is a class that creates the introspection and data instances for NTScalar and
an a NTScalar instance itself.</p>
<p><b>ntscalar.h</b> defines the following:</p>
<pre>
class NTScalar;
typedef std::tr1::shared_ptr&lt;NTScalar&gt; NTScalarPtr;

class NTScalarBuilder
{
public:
    POINTER_DEFINITIONS(NTScalarBuilder);
    shared_pointer value(ScalarType scalarType);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    shared_pointer addDisplay();
    shared_pointer addControl();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTScalarPtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>value</dt>
    <dd>This determines the scalar type for the value field.
     This must be specified or createStructure will throw an exception.</dd>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
  <dt>addDisplay</dt>
     <dd>Add optional field display.</dd>
  <dt>addControl</dt>
     <dd>Add optional field control.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>
<p>An NTScalarBuilder can be used to create multiple PVStructure and/or NTScalar instances.
Each time createPVScalar is called it clears all internal data after the PVStructure
is created.</p>
<h4>NTScalarBuilder Examples</h4>
<p>An example of creating an NTScalar instance is:</p>
<pre>
NTScalarBuilderPtr builder = NTScalar::createBuilder();
NTScalarPtr ntScalar = builder-&gt;
    value(pvInt)-&gt;
    addDescriptor()-&gt;
    addAlarm()-&gt;
    addTimeStamp()-&gt;
    addDisplay()-&gt;
    addControl()-&gt;
    create();
</pre>
<p>The same results could be done by:</p>
<pre>
NTScalarBuilderPtr builder = NTScalar::createBuilder();
builder-&gt;value(pvInt);
builder-&gt;addDescriptor();
builder-&gt;addAlarm();
builder-&gt;addTimeStamp();
builder-&gt;addDisplay();
builder-&gt;addControl();
NTScalarPtr ntScalar = builder-&gt;create();
</pre>

<h3>NTScalar</h3>
<p><b>ntscalar.h</b> defines the following:</p>
<pre>
class NTScalar;
typedef std::tr1::shared_ptr&lt;NTScalar&gt; NTScalarPtr;

class NTScalar
{
public:
    POINTER_DEFINITIONS(NTScalar);
    ~NTScalar() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTScalarBuilderPtr createBuilder();

    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    bool attachDisplay(PVDisplay &amp;pvDisplay) const;
    bool attachControl(PVControl &amp;pvControl) const;
    PVStructurePtr getPVStructure() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVStructurePtr getDisplay() const;
    PVStructurePtr getControl() const;
    PVFieldPtr getValue() const;
    template&lt;typename PVT&gt;
    std::tr1::shared_ptr&lt;PVT&gt; getValue() const
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTScalar that wraps it.
       It calls <b>isCompatible</b>.
       It returns a null PVScalar if <b>isCompatible</b> returns false.
       <br />
The primary use of wrap is by pvAccess client code.
The server creates a PVStructure that is valid for an NTScalar
and passes it to the client.
The client can call wrap to create an NTScalar for it's own use.
An example is:
<pre>
void myCallback(PVStructurePtr const &amp; PVStructure)
{
     NTScalarPtr ntscalar = NTScalar::wrap(PVStructure);
     if(!ntscalar) {
       // not a valid NTScalar
     }
     ...
}
</pre>
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTScalar that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTScalar.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTScalar.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates an NTScalarBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTScalar is attached to pvTimeStamp.
      <br />
An example is:
<pre>
PVTimeStamp pvTimeStamp;
TimeStamp timeStamp;

ntscalar-&gt;attachTimeStamp(pvTimeStamp);
pvTimeStamp.get(timeStamp);
TimeStamp current;
current.getCurrent();
double diff = TimeStamp::diff(timeStamp,current); // timeStamp - current
</pre>
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTScalar is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.<br />
An example is:
<pre>
PVAlarm pvAlarm;
Alarm alarm;

ntscalar-&gt;attachAlarm(pvAlarm);
pvAlarm.get(alarm);
int severity = alarm.getSeverity();
int status = alarm.getStatus();
string message = alarm.getMessage();
</pre>
      </dd>
   <dt>attachDisplay</dt>
      <dd>The display field of the NTScalar is attached to pvDisplay.
      Used similar to attachAlarm.
      </dd>
   <dt>attachControl</dt>
      <dd>The control field of the NTScalar is attached to pvControl.
      Used similar to attachAlarm.
    </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTScalar wraps.</dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getDisplay</dt>
       <dd>Returns the top-level display.
       If the display was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getControl</dt>
       <dd>Returns the top-level control.
       If the control was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getValue</dt>
       <dd>Returns the value field.</dd>
</dl>
<h2>Normative Type NTScalarArray</h2>
<p>This class is similar to <b>NTScalar</b> except that the value
field is a scalar array field instead of just a scalar.</p>
<p>This has the following fields:</p>
<pre>
epics:nt/NTScalarArray:1.0
    double[] value                      // mandatory and can be any numeric type
    string descriptor                   // optional
    alarm_t alarm                       // optional
        int severity
        int status 
        string message
    time_t timeStamp                    // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    display_t display                   // optional
        double limitLow
        double limitHigh
        string description
        string format
        string units
    control_t control                   // optional
        double limitLow
        double limitHigh
        double minStep
    string extra1                       // extra
    string[] extra2                     //
</pre>
<h3>NTScalarArrayBuilder</h3>
<p><b>ntscalarArray.h</b> defines the following:</p>
<pre>
class NTScalarArray;
typedef std::tr1::shared_ptr&lt;NTScalarArray&gt; NTScalarArrayPtr;

class NTScalarArrayBuilder
{
public:
    POINTER_DEFINITIONS(NTScalarArrayBuilder);
    shared_pointer arrayValue(ScalarType elementType);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    shared_pointer addDisplay();
    shared_pointer addControl();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTScalarArrayPtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>arrayValue</dt>
    <dd>This determines the element type for the value field.
     This must be specified or createStructure will throw an exception.</dd>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
  <dt>addDisplay</dt>
     <dd>Add optional field display.</dd>
  <dt>addControl</dt>
     <dd>Add optional field control.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>
<h3>NTScalarArray</h3>
<p><b>ntscalarArray.h</b> defines the following:</p>
<pre>
class NTScalarArray;
typedef std::tr1::shared_ptr&lt;NTScalarArray&gt; NTScalarArrayPtr;

class NTScalarArray
{
public:
    POINTER_DEFINITIONS(NTScalarArray);
    ~NTScalarArray() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTScalarArrayBuilderPtr createBuilder();

    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    bool attachDisplay(PVDisplay &amp;pvDisplay) const;
    bool attachControl(PVControl &amp;pvControl) const;
    PVStructurePtr getPVStructure() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVStructurePtr getDisplay() const;
    PVStructurePtr getControl() const;
    PVFieldPtr getValue() const;
    template&lt;typename PVT&gt;
    std::tr1::shared_ptr&lt;PV&gt; getValue() const
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTScalarArray that wraps it.
       It calls <b>isCompatible</b> and returns a null PVScalarArray if <b>isCompatible</b> returns false.
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTScalarArray that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTScalarArray.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTScalarArray.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates a NTScalarArrayBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTScalarArray is attached to pvTimeStamp.
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTScalarArray is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.
      </dd>
   <dt>attachDisplay</dt>
      <dd>The display field of the NTScalarArray is attached to pvDisplay.
      Used similar to attachAlarm.
      </dd>
   <dt>attachControl</dt>
      <dd>The control field of the NTScalarArray is attached to pvControl.
      Used similar to attachAlarm.
    </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTScalarArray wraps.</dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getDisplay</dt>
       <dd>Returns the top-level display.
       If the display was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getControl</dt>
       <dd>Returns the top-level control.
       If the control was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getValue</dt>
       <dd>Returns the value field.</dd>
</dl>

<h2>Normative Type NTNameValue</h2>
<pre>
epics:nt/NTNameValue:1.0
    string[] name                 // mandatory
    double[] value                // mandatory, can be any type, must be same length as name
    string descriptor             // optional
    alarm_t alarm                 // optional
        int severity
        int status
        string message
    time_t timeStamp              // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    string extra1                 // extra
    string[] extra2               // extra
</pre>

<h3>NTNameValueBuilder</h3>
<p><b>ntnameValue.h</b> defines the following:</p>
<pre>
class NTNameValue;
typedef std::tr1::shared_ptr&lt;NTNameValue&gt; NTNameValuePtr;

class NTNameValueBuilder
{
public:
    POINTER_DEFINITIONS(NTNameValueBuilder);
    shared_pointer value(ScalarType scalarType);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTNameValuePtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>value</dt>
    <dd>This determines the element type for the value field.
     This must be specified or createStructure will throw an exception.</dd>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>

<h3>NTNameValue</h3>
<pre>
class NTNameValue;
typedef std::tr1::shared_ptr&lt;NTNameValue&gt; NTNameValuePtr;

class NTNameValue
{
public:
    POINTER_DEFINITIONS(NTNameValue);
    ~NTNameValue() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTNameValueBuilderPtr createBuilder();

    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    PVStringPtr getDescriptor() const;
    PVStructurePtr getPVStructure() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVStringArrayPtr getName() const;
    PVFieldPtr getValue() const;
    template&lt;typename PVT&gt;
    std::tr1::shared_ptr&lt;PV&gt; getValue() const
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTNameValue that wraps it.
       It calls <b>isCompatible</b> and returns a null NTNameValue if <b>isCompatible</b> returns false.
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTNameValue that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTNameValue.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTNameValue.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates an NTNameValueBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTNameValue is attached to pvTimeStamp.
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTNameValue is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.
      </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTNameValue wraps.</dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getName</dt>
       <dd>Returns field name.</dd>
   <dt>getValue</dt>
       <dd>Returns field value.</dd>
</dl>

<h2>Normative Type NTTable</h2>
<pre>
epics:nt/NTTable:1.0 
    string[] labels [column0,column1,column2]    // mandatory
    structure value                              // mandatory
        double[] column0 []                      // can be any scalar type
        string[] column1 []                      // can be any scalar type
        int[] column2 []                         // can be any scalar type
    string descriptor                            // optional
    alarm_t alarm                                // optional
        int severity 
        int status 
        string
    time_t timeStamp                             // optional
        long secondsPastEpoch
        int nanoseconds 498486530
        int userTag
    string extra1                                // extra
</pre>

<h3>NTTableBuilder</h3>
<p><b>nttable.h</b> defines the following:</p>
<pre>
class NTTable;
typedef std::tr1::shared_ptr&lt;NTTable&gt; NTTablePtr;

class NTTableBuilder
{
public:
    POINTER_DEFINITIONS(NTTableBuilder);
    shared_pointer addColumn(string const &amp; name,ScalarType scalarType);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTTablePtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>addColumn</dt>
    <dd>This is the name and elementType for the next column</dd>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>
<h3>NTTable</h3>
<pre>
class NTTable;
typedef std::tr1::shared_ptr&lt;NTTable&gt; NTTablePtr;

class NTTable
{
public:
    POINTER_DEFINITIONS(NTTable);
    ~NTTable() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTTableBuilderPtr createBuilder();

    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    PVStructurePtr getPVStructure() const;
    PVStringPtr getDescriptor() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVStringArrayPtr getLabels() const;
    PVFieldPtr getColumn(string const &amp; columnName) const;
    template&lt;typename PVT&gt;
    std::tr1::shared_ptr&lt;PV&gt; getColumn(string const &amp; columnName) const;
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTTable that wraps it.
       It calls <b>isCompatible</b> and returns a null NTTable if <b>isCompatible</b> returns false.
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTTable that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTTable.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTTable.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates an NTTableBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTTable is attached to pvTimeStamp.
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTTable is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.
      </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTTable wraps.</dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getLabels</dt>
       <dd>Returns the labels field.</dd>
   <dt>getColumn</dt>
       <dd>Returns the column with the specified name.</dd>
</dl>

<h2>Normative Type NTMultiChannel</h2>
<pre>
structure NTMultiChannel
  union_t[] value            // mandatory
  string[]  channelName      // mandatory; must be same length as value
  time_t    timeStamp        // optional; time when data collected
  alarm_t   alarm            // optional; alarm associated with data collection
  int[]     severity         // optional; alarm severity for each value
  int[]     status           // optional; alarm status for each value
  string[]  message          // optional; alarm message for each value
  long[]    secondsPastEpoch // optional; seconds for each value.
  int[]     nanoseconds      // optional; nanoseconds for each value
  string    descriptor       // optional; descriptor data
</pre>
<h3>NTMultiChannelBuilder</h3>
<p><b>ntmultiChannel.h</b> defines the following:</p>
<pre>
class NTMultiChannel;
typedef std::tr1::shared_ptr&lt;NTMultiChannel&gt; NTMultiChannelPtr;

class NTMultiChannelBuilder
{
public:
    POINTER_DEFINITIONS(NTMultiChannelBuilder);
    shared_pointer value(UnionConstPtr valuePtr);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    shared_pointer addSeverity();
    shared_pointer addStatus();
    shared_pointer addMessage();
    shared_pointer addSecondsPastEpoch();
    shared_pointer addNanoseconds();
    shared_pointer addUserTag();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTMultiChannelPtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>value</dt>
    <dd>This determines the element type for the value field.
    If not specified the type will be a variant union.
    </dd>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
  <dt>addSeverity</dt>
     <dd>Add a field that has the alarm severity for each channel.</dd>
  <dt>addStatus</dt>
     <dd>Add a field that has the alarm status for each channel.</dd>
  <dt>addMessage</dt>
     <dd>Add a field that has the alarm message for each channel.</dd>
  <dt>addSecondsPastEpoch</dt>
     <dd>Add a field that has the secondsPastEpoch for each channel.</dd>
  <dt>addNanoseconds</dt>
     <dd>Add a field that has the nanoseconds for each channel.</dd>
  <dt>addUserTag</dt>
     <dd>Add a field that has the userTag for each channel.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>
<h3>NTMultiChannel</h3>
<pre>
class NTMultiChannel;
typedef std::tr1::shared_ptr&lt;NTMultiChannel&gt; NTMultiChannelPtr;

class NTMultiChannel
{
public:
    POINTER_DEFINITIONS(NTMultiChannel);
    ~NTMultiChannel() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTMultiChannelBuilderPtr createBuilder();

    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    PVStringPtr getDescriptor() const;
    PVStructurePtr getPVStructure() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVUnionArrayPtr getValue() const;
    PVStringArrayPtr getChannelName() const;
    PVBooleanArrayPtr getIsConnected() const;
    PVIntArrayPtr getSeverity() const;
    PVIntArrayPtr getStatus() const;
    PVStringArrayPtr getMessage() const;
    PVLongArrayPtr getSecondsPastEpoch() const;
    PVIntArrayPtr getNanoseconds() const;
    PVIntArrayPtr getUserTag() const;
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTMultiChannel that wraps it.
       It calls <b>isCompatible</b> and returns a null NTMultiChannel if <b>isCompatible</b> returns false.
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTMultiChannel that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTMultiChannel.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTMultiChannel.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates an NTMultiChannelBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTMultiChannel is attached to pvTimeStamp.
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTMultiChannel is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.
      </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTMultiChannel wraps.</dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getValue</dt>
       <dd>Returns the value field.</dd>
   <dt>getChannelName</dt>
       <dd>Returns the name of each channel.</dd>
   <dt>getIsConnected</dt>
       <dd>Returns connection state of each channel.</dd>
   <dt>getSeverity</dt>
       <dd>Returns the severity of each channel.</dd>
   <dt>getStatus</dt>
       <dd>Returns the status of each channel.</dd>
   <dt>getMessage</dt>
       <dd>Returns the message of each channel.</dd>
   <dt>getSecondsPastEpoch</dt>
       <dd>Returns the secondsPastEpoch of each channel.</dd>
   <dt>getNanoseconds</dt>
       <dd>Returns the nanoseconds of each channel.</dd>
   <dt>getUserTag</dt>
       <dd>Returns the userTag of each channel.</dd>
</dl>

<h2>Normative Type NTNDArray</h2> 
<pre>
epics:nt/NTNDArray:1.0 
    union value                                 // mandatory
    codec_t codec                               // mandatory
        string name 
        any parameters
    long compressedSize                         // mandatory
    long uncompressedSize                       // mandatory
    dimension_t[] dimension                     // mandatory
        dimension_t[]
            dimension_t
                int size
                int offset
                int fullSize
                int binning
                boolean reverse
    int uniqueId                                // mandatory
    time_t dataTimeStamp                        // mandatory
        long secondsPastEpoch
        int nanoseconds
        int userTag
    epics:nt/NTAttribute:1.0[] attribute        // mandatory
        epics:nt/NTAttribute:1.0[]
            epics:nt/NTAttribute:1.0
                string name
                any value
                string description
                int sourceType
                string source
    string descriptor                           // optional
    time_t timeStamp                            // optional
        long secondsPastEpoch
        int nanoseconds
        int userTag
    alarm_t alarm                               // optional
        int severity
        int status
        string message 
    display_t display                           // optional
        double limitLow
        double limitHigh
        string description 
        string format 
        string units 
    string extra1                               // extra
</pre>
<h3>NTNDArrayBuilder</h3>
<p><b>ntndArray.h</b> defines the following:</p>
<pre>
class NTNDArray;
typedef std::tr1::shared_ptr&lt;NTNDArray&gt; NTNDArrayPtr;

class NTNDArrayBuilder
{
public:
    POINTER_DEFINITIONS(NTNDArrayBuilder);
    shared_pointer addDescriptor();
    shared_pointer addAlarm();
    shared_pointer addTimeStamp();
    shared_pointer addDisplay();
    StructureConstPtr createStructure();
    PVStructurePtr createPVStructure();
    NTNDArrayPtr create();
    shared_pointer add(
         string const &amp; name,
         FieldConstPtr const &amp; field);
private:
}
</pre>
where
<dl>
  <dt>addDescriptor</dt>
     <dd>Add optional field descriptor.</dd>
  <dt>addAlarm</dt>
     <dd>Add optional field alarm.</dd>
  <dt>addTimeStamp</dt>
     <dd>Add optional field timeStamp.</dd>
  <dt>addDisplay</dt>
     <dd>Add optional field display.</dd>
   <dt>createStructure</dt>
     <dd>Create an introspection instance.</dd>
  <dt>createPVStructure</dt>
     <dd>Create the data instance.</dd>
   <dt>create</dt>
      <dd>create a PVScalar instance.</dd>
  <dt>add</dt>
     <dd>Add an extra field. As many fields as desired can be added but each must have
      a unique name that is not the name of any mandatory or possible optional field.</dd>
</dl>
<h3>NTNDArray</h3>
<pre>
class NTNDArray;
typedef std::tr1::shared_ptr&lt;NTNDArray&gt; NTNDArrayPtr;

class NTNDArray
{
public:
    POINTER_DEFINITIONS(NTNDArray);
    ~NTNDArray() {}
    static shared_pointer wrap(PVStructurePtr const &amp; structure);
    static shared_pointer wrapUnsafe(PVStructurePtr const &amp; structure);
    static bool is_a(StructureConstPtr const &amp; structure);
    static bool isCompatible(PVStructurePtr const &amp;pvStructure);
    static NTNDArrayBuilderPtr createBuilder();

    PVStringPtr getDescriptor() const;
    bool attachTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachDataTimeStamp(PVTimeStamp &amp;pvTimeStamp) const;
    bool attachAlarm(PVAlarm &amp;pvAlarm) const;
    PVStructurePtr getPVStructure() const;
    PVUnionPtr getValue() const;
    PVStructurePtr getCodec() const;
    PVLongPtr getCompressedDataSize() const;
    PVLongPtr getUncompressedDataSize() const;
    PVStructureArrayPtr getAttribute() const;
    PVStructureArrayPtr getDimension() const;
    PVIntPtr getUniqueId() const;
    PVStructurePtr getDataTimeStamp() const;
    PVStringPtr getDescriptor() const;
    PVStructurePtr getTimeStamp() const;
    PVStructurePtr getAlarm() const;
    PVStructurePtr getDisplay() const;
private:
}
</pre>
where
<dl>
   <dt>wrap</dt>
     <dd>Given a PVStructure this creates an NTNDArray that wraps it.
       It calls <b>isCompatible</b> and returns a null NTNDArray if <b>isCompatible</b> returns false.
     </dd>
   <dt>wrapUnsafe</dt>
     <dd>Given a PVStructure this creates an NTNDArray that wraps it.
      It does not check that the introspection interface is compatible.
      This method is dangerous.</dd>
   <dt>is_a</dt>
      <dd>This method checks to see if the structure has an ID that is 
      correct for NTNDArray.</dd>
   <dt>isCompatible</dt>
       <dd>This method checks to see if the PVStructure has appropriate
       fields to be an NTNDArray.
       </dd>
   <dt>createBuilder</dt>
       <dd>This  method creates an NTNDArrayBuilder.</dd>
   <dt>attachTimeStamp</dt>
      <dd>The timeStamp field of the NTNDArray is attached to pvTimeStamp.
      </dd>
   <dt>attachDataTimeStamp</dt>
      <dd>The dataTimeStamp field of the NTNDArray is attached to pvTimeStamp.
      </dd>
   <dt>attachAlarm</dt>
      <dd>The alarm field of the NTNDArray is attached to pvAlarm.
       If alarm is not selected as an optional field false is returned.
      If this is successful then the pvAlarm can be used to access that alarm
       fields.
      </dd>
   <dt>getPVStructure</dt>
       <dd>Returns the PVStructure that NTNDArray wraps.</dd>
   <dt>getValue</dt>
       <dd>Returns the value field.</dd>
   <dt>getCodec</dt>
       <dd>Returns the severity of each channel.</dd>
   <dt>getCompressedDataSize</dt>
       <dd>Returns the name of each channel.</dd>
   <dt>getUncompressedDataSize</dt>
       <dd>Returns connection state of each channel.</dd>
   <dt>getAttribute</dt>
       <dd>Returns the status of each channel.</dd>
   <dt>getDimension</dt>
       <dd>Returns the message of each channel.</dd>
   <dt>getUniqueId</dt>
       <dd>Returns the secondsPastEpoch of each channel.</dd>
   <dt>getDataTimeStamp</dt>
       <dd>Returns the data timeStamp.
       </dd>
    <dt>getDescriptor</dt>
       <dd>Get the descriptor.</dd>
   <dt>getTimeStamp</dt>
       <dd>Returns the top-level timeStamp.
       If the timeStamp was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getAlarm</dt>
       <dd>Returns the top-level alarm.
       If the alarm was not selected as an optional field
       a null PVStructure is returned.
       </dd>
   <dt>getDisplay</dt>
       <dd>Returns the top-level display.
       If the display was not selected as an optional field
       a null PVStructure is returned.
       </dd>
</dl>


</div>
</body>
</html>
