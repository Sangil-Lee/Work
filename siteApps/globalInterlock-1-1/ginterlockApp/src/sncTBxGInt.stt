program sncTBxGInt
option +r; 
option +c; 
option -a; 

%%#include <math.h> 


float tbxGI_setpt[6];
assign tbxGI_setpt to {
"SCL31-CDL01:EBx01-CV7501:Setpt",		"IF-CDL07:EBx01-CV7501:Setpt",
"SCL31-CDL01:EBx01-CV7401:Setpt",		"SCL31-CDL01:EBx01-CV7402:Setpt",
"IF-CDL07:EBx01-CV7401:Setpt",			"IF-CDL07:EBx01-CV7402:Setpt"
};

int tbxGI_setmanuclose[2];
assign tbxGI_setmanuclose to {
"SCL32-CDL02:VBx01-XV7301:SetManuClose","SCL22-CDL06:VBx25-XV7301:SetManuClose"
};

int tbx_intstat[8];
assign tbx_intstat to {
"SCL31-CDL01:EBx01-CV7501:IntStatTBxPT7506G", "IF-CDL07:EBx01-CV7501:IntStatTBxPT7546G",
"SCL31-CDL01:EBx01-CV7401:IntStatTBxPT7303G", "SCL31-CDL01:EBx01-CV7402:IntStatTBxPT7303G",
"IF-CDL07:EBx01-CV7401:IntStatTBxPT7343G",	  "IF-CDL07:EBx01-CV7402:IntStatTBxPT7343G"
"SCL32-CDL02:VBx01-XV7301:IntStatTBxPT7203G", "SCL22-CDL06:VBx25-XV7301:IntStatTBxPT7243G"
};

monitor tbx_intstat;
evflag  evTBXIntstat;
sync tbx_intstat  evTBXIntstat;

int idxcount = 8;
ss ssTBxInterlock {
	state init {
		when(TRUE)
		{
			
		}state TBxGInterlock 
	}

	state TBxGInterlock
	{
		when(efTest(evTBXIntstat))
		{
			int i = 0;
			for( ; i < idxcount;i++)
			{
				if (i < 6 && tbx_intstat[i] == 1) {
					tbxGI_setpt[i] = 0;
					pvPut(tbxGI_setpt[i], SYNC);
				} else {
					//Shut-off valve close
					tbxGI_setmanuclose[i] = 1;
					pvPut(tbxGI_setmanuclose[i], SYNC);
				};
			}
			efClear(evTBXIntstat);
		} state GoDelay
	}

	state GoDelay
	{
		when(delay(1.0))
		{
			efSet(evTBXIntstat);
		}state TBxGInterlock
	}
}

