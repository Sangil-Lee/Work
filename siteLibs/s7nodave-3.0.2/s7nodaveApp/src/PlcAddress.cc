#include <stdlib.h>

#include "PlcAddress.h"
#include "utilities.h"

namespace s7nodave {

bool PlcAddress::operator==(const PlcAddress& other) const {
    return this->area == other.area
        && this->areaNumber == other.areaNumber
        && this->dataSize == other.dataSize
        && this->startBit == other.startBit
        && this->startByte == other.startByte;
}

s7nodavePlcArea PlcAddress::getArea() const {
    return this->area;
}

int PlcAddress::getAreaNumber() const {
    return this->areaNumber;
}

s7nodavePlcDataSize PlcAddress::getDataSize() const {
    return this->dataSize;
}

int PlcAddress::getStartByte() const {
    return this->startByte;
}

char PlcAddress::getStartBit() const {
    return this->startBit;
}

std::string PlcAddress::toString() const {
    // Buffer for holding temporary string generated by snprintf.
    // The 32 characters are sufficient for all numbers valid in PLC addresses.
    char buf[32];
    std::string output;
    output.append(areaToString(this->area));
    if (this->area == plcAreaDb) {
        snprintf(buf, 32, "%d", this->areaNumber);
        output.append(buf);
        output.append(".");
        output.append(areaToString(plcAreaDb));
    }
    if (this->area != plcAreaTimer && this->area != plcAreaCounter) {
        output.append(dataSizeToString(this->dataSize, this->area == plcAreaDb));
    }
    snprintf(buf, 32, "%d", this->startByte);
    output.append(buf);
    if (this->dataSize == plcDataSizeBit) {
        output.append(".");
        snprintf(buf, 32, "%d", this->startBit);
        output.append(buf);
    }
    return output;
}

std::string PlcAddress::areaToString(s7nodavePlcArea area) {
    switch (area) {
    case plcAreaDb:
        return "DB";
    case plcAreaFlags:
        return "F";
    case plcAreaInputs:
        return "I";
    case plcAreaOutputs:
        return "Q";
    case plcAreaTimer:
        return "T";
    case plcAreaCounter:
        return "C";
    default:
        return "";
    }
}

Optional<s7nodavePlcArea> PlcAddress::stringToArea(std::string areaString) {
    toUpper(areaString);
    if (areaString.size() == 1) {
        char c = areaString[0];
        switch (c) {
        case 'F':
        case 'M':
            return plcAreaFlags;
        case 'I':
        case 'E':
            return plcAreaInputs;
        case 'Q':
        case 'A':
            return plcAreaOutputs;
        case 'T':
            return plcAreaTimer;
        case 'C':
        case 'Z':
            return plcAreaCounter;
        default:
            return Optional<s7nodavePlcArea>();
        }
    } else if (areaString.size() == 2) {
        char c1 = areaString[0];
        char c2 = areaString[1];
        if (c1 == 'D' && c2 == 'B') {
            return plcAreaDb;
        } else {
            return Optional<s7nodavePlcArea>();
        }
    } else {
        return Optional<s7nodavePlcArea>();
    }
}

std::string PlcAddress::dataSizeToString(s7nodavePlcDataSize dataSize, bool isDB) {
    switch (dataSize) {
    case plcDataSizeBit:
        if (isDB) {
            return "X";
        } else {
            // Outside of DB blocks, bit addresses do not have a prefix.
            return "";
        }
    case plcDataSizeByte:
        return "B";
    case plcDataSizeWord:
        return "W";
    case plcDataSizeDword:
        return "D";
    default:
        // We return the empty string both for bit and unknown data size.
        return "";
    }
}

Optional<s7nodavePlcDataSize> PlcAddress::stringToDataSize(std::string dataSizeString, bool isDB) {
    toUpper(dataSizeString);
    if (dataSizeString.size() == 0 && !isDB) {
        return plcDataSizeBit;
    } else if (dataSizeString.size() == 1) {
        char c = dataSizeString[0];
        switch (c) {
        case 'B':
            return plcDataSizeByte;
        case 'W':
            return plcDataSizeWord;
        case 'D':
            return plcDataSizeDword;
        case 'X':
            if (isDB) {
                return plcDataSizeBit;
            } else {
                return Optional<s7nodavePlcDataSize>();
            }
        default:
            return Optional<s7nodavePlcDataSize>();
        }
    } else {
        return Optional<s7nodavePlcDataSize>();
    }
}

int PlcAddress::dataSizeInBits(s7nodavePlcDataSize dataSize) {
    switch (dataSize) {
    case plcDataSizeBit:
        return 1;
    case plcDataSizeByte:
        return 8;
    case plcDataSizeWord:
        return 16;
    case plcDataSizeDword:
        return 32;
    default:
        return -1;
    }
}

Optional<PlcAddress> PlcAddress::create(s7nodavePlcArea area, int areaNumber, s7nodavePlcDataSize dataSize, int startByte, int startBit) {
    Optional<PlcAddress> emptyResult;
    if (area != plcAreaDb && areaNumber != 0) {
        // area number must be null for all areas except DB
        return emptyResult;
    }
    if (dataSize != plcDataSizeBit && startBit != 0) {
        // start bit is only allowed for bits
        return emptyResult;
    }
    if (startBit < 0 || startBit > 7) {
        // start bit must be a number between 0 and 7
        return emptyResult;
    }
    if (startByte < 0) {
        // startByte must be positive
        return emptyResult;
    }
    return PlcAddress(area, areaNumber, dataSize, startByte, startBit);
}

namespace {

const std::string digits = "0123456789";

} // anonymous namesapce

Optional<PlcAddress> PlcAddress::create(std::string addressString) {
    Optional<PlcAddress> emptyResult;
    if (addressString.size() < 2) {
        // The shortest valid address has two characters
        return emptyResult;
    }
    Optional<s7nodavePlcArea> area = stringToArea(addressString.substr(0, 2));
    if (area) {
        addressString = addressString.substr(2);
    } else {
        area = stringToArea(addressString.substr(0, 1));
        if (area) {
            addressString = addressString.substr(1);
        } else {
            return emptyResult;
        }
    }
    if (addressString.size() < 1) {
        // An address which only specifies an area, is not valid.
        return emptyResult;
    }

    // We need some special handling for DB-, counter- and timer-type addresses
    int areaNumber = 0;
    if (*area == plcAreaDb) {
        // The next characters are the area number, until we see a dot
        size_t pos = 0;
        pos = addressString.find_first_not_of(digits);
        if (pos == std::string::npos) {
            // We reached the end of the string without finding a dot.
            return emptyResult;
        }
        auto areaNumberString = addressString.substr(0, pos);
        if (areaNumberString.size() == 0) {
            // DB number is missing
            return emptyResult;
        }
        areaNumber = atoi(areaNumberString.c_str());
        // Cut number and dot
        addressString = addressString.substr(pos + 1);
        if (addressString.size() < 2) {
            // We can expect at least two characters for the following "DB"
            return emptyResult;
        }
        // We can misuse stringToArea to look for the "DB" string
        auto tempArea = stringToArea(addressString.substr(0, 2));
        if (tempArea && *tempArea == plcAreaDb) {
            // Cut "DB"
            addressString = addressString.substr(2);
        } else {
            // Not a valid address
            return emptyResult;
        }
    } else if (*area == plcAreaTimer || *area == plcAreaCounter) {
        // Counters and timer do not specify a data size, they are always
        // words.
        // The remaining characters should be digits only.
        if (addressString.find_first_not_of(digits) != std::string::npos) {
            return emptyResult;
        }
        int number = atoi(addressString.c_str());
        return PlcAddress(*area, 0, plcDataSizeWord, number, 0);
    }

    // Now we have to determine the data size.
    if (addressString.length() < 2) {
        // We can expect at least two characters
        return emptyResult;
    }
    auto dataSize = stringToDataSize(addressString.substr(0, 1), *area == plcAreaDb);
    if (!dataSize) {
        if (*area != plcAreaDb && addressString.find_first_of(digits) == 0) {
            // The next character is a digit, so might be a bit
            dataSize = plcDataSizeBit;
        } else {
            // Invalid address
            return emptyResult;
        }
    } else {
        addressString = addressString.substr(1);
    }
    // If we expect a bit address, we need a more complex parsing,
    // otherwise all remaining characters should be digits.
    int startByte = 0;
    char startBit = 0;
    if (*dataSize == plcDataSizeBit) {
        // Search for the dot
        size_t pos = addressString.find_first_not_of(digits);
        if (pos == std::string::npos || addressString[pos] != '.') {
            // We reached the end of the string without finding a dot.
            return emptyResult;
        }
        startByte = atoi(addressString.substr(0, pos).c_str());
        addressString = addressString.substr(pos + 1);
        if (addressString.size() != 1 || addressString.find_first_not_of(digits) != std::string::npos) {
            // There must be exactly one digit after the dot
            return emptyResult;
        }
        startBit = atoi(addressString.c_str());
        if (startBit < 0 || startBit > 7) {
            // Invalid start bit
            return emptyResult;
        }
    } else {
        if (addressString.find_first_not_of(digits) != std::string::npos) {
            // Illegal character
            return emptyResult;
        }
        startByte = atoi(addressString.c_str());
    }
    return PlcAddress(*area, areaNumber, *dataSize, startByte, startBit);
}

PlcAddress::PlcAddress(s7nodavePlcArea area, int areaNumber, s7nodavePlcDataSize dataSize, int startByte, char startBit) {
    this->area = area;
    this->areaNumber = areaNumber;
    this->dataSize = dataSize;
    this->startByte = startByte;
    this->startBit = startBit;
}

} // namespace s7nodave
